// Code generated by sqlc. DO NOT EDIT.
// source: song.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addSong = `-- name: AddSong :one
insert into songs (
    name,
    release_date,
    text,
    link,
    group_name
) values (
          $1, $2, $3, $4, $5
         )
returning id, name, release_date, link, text, group_name
`

type AddSongParams struct {
	Name        string    `json:"name"`
	ReleaseDate time.Time `json:"release_date"`
	Text        string    `json:"text"`
	Link        string    `json:"link"`
	GroupName   string    `json:"group_name"`
}

func (q *Queries) AddSong(ctx context.Context, arg AddSongParams) (Song, error) {
	row := q.queryRow(ctx, q.addSongStmt, addSong,
		arg.Name,
		arg.ReleaseDate,
		arg.Text,
		arg.Link,
		arg.GroupName,
	)
	var i Song
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ReleaseDate,
		&i.Link,
		&i.Text,
		&i.GroupName,
	)
	return i, err
}

const deleteSong = `-- name: DeleteSong :exec
delete from songs
where id = $1
`

func (q *Queries) DeleteSong(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteSongStmt, deleteSong, id)
	return err
}

const getSong = `-- name: GetSong :one
SELECT release_date, text, link
FROM songs
where group_name = $1 and name = $2
`

type GetSongParams struct {
	GroupName string `json:"group_name"`
	Name      string `json:"name"`
}

type GetSongRow struct {
	ReleaseDate time.Time `json:"release_date"`
	Text        string    `json:"text"`
	Link        string    `json:"link"`
}

func (q *Queries) GetSong(ctx context.Context, arg GetSongParams) (GetSongRow, error) {
	row := q.queryRow(ctx, q.getSongStmt, getSong, arg.GroupName, arg.Name)
	var i GetSongRow
	err := row.Scan(&i.ReleaseDate, &i.Text, &i.Link)
	return i, err
}

const getSongLyrics = `-- name: GetSongLyrics :many
SELECT
    array_to_string(
            (string_to_array(text, E'\n\n'))[ (($2 - 1) * $3 + 1) : (($2 - 1) * $3 + $3) ],
            E'\n\n'
    ) AS paginated_verses
FROM songs
WHERE id = $1
`

type GetSongLyricsParams struct {
	ID      uuid.UUID   `json:"id"`
	Column2 interface{} `json:"column_2"`
	Column3 interface{} `json:"column_3"`
}

func (q *Queries) GetSongLyrics(ctx context.Context, arg GetSongLyricsParams) ([]string, error) {
	rows, err := q.query(ctx, q.getSongLyricsStmt, getSongLyrics, arg.ID, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var paginated_verses string
		if err := rows.Scan(&paginated_verses); err != nil {
			return nil, err
		}
		items = append(items, paginated_verses)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSongs = `-- name: ListSongs :many
SELECT id, name, release_date, link, text, group_name
FROM songs
LIMIT $1
OFFSET $2
`

type ListSongsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSongs(ctx context.Context, arg ListSongsParams) ([]Song, error) {
	rows, err := q.query(ctx, q.listSongsStmt, listSongs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Song{}
	for rows.Next() {
		var i Song
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ReleaseDate,
			&i.Link,
			&i.Text,
			&i.GroupName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSong = `-- name: UpdateSong :one
update songs set
                 name = $2,
                 release_date = $3,
                 text = $4,
                 link = $5,
                 group_name = $6
where id = $1
returning id, name, release_date, link, text, group_name
`

type UpdateSongParams struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	ReleaseDate time.Time `json:"release_date"`
	Text        string    `json:"text"`
	Link        string    `json:"link"`
	GroupName   string    `json:"group_name"`
}

func (q *Queries) UpdateSong(ctx context.Context, arg UpdateSongParams) (Song, error) {
	row := q.queryRow(ctx, q.updateSongStmt, updateSong,
		arg.ID,
		arg.Name,
		arg.ReleaseDate,
		arg.Text,
		arg.Link,
		arg.GroupName,
	)
	var i Song
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ReleaseDate,
		&i.Link,
		&i.Text,
		&i.GroupName,
	)
	return i, err
}
